import os
import subprocess
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import threading
import urllib.request
import zipfile
import tarfile
import platform
import shutil

class AudiobookApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Auto-Config Audiobook Builder (M4B)")
        self.root.geometry("600x650")
        self.root.configure(bg="#f1f5f9")

        self.files = []
        self.ffmpeg_path = "ffmpeg" # Default
        self.ffmpeg_ready = self.check_ffmpeg_silent()

        # --- UI Layout ---
        header = tk.Frame(root, bg="#8b5cf6", height=60)
        header.pack(fill="x")
        tk.Label(header, text="AUDIOBOOK BUILDER", font=("Arial", 14, "bold"), fg="white", bg="#8b5cf6").pack(pady=15)

        # Automation Status / Download Section
        self.setup_frame = tk.Frame(root, bg="#f8fafc", pady=15)
        self.setup_frame.pack(fill="x", padx=20, pady=10)
        
        self.setup_label = tk.Label(self.setup_frame, text="Checking System Engine...", bg="#f8fafc", font=("Arial", 10, "bold"))
        self.setup_label.pack()

        self.setup_progress = ttk.Progressbar(self.setup_frame, length=400, mode='determinate')
        self.setup_progress.pack(pady=10)
        
        if not self.ffmpeg_ready:
            self.setup_label.config(text="FFmpeg Missing. Starting Automatic Download...", fg="#991b1b")
            threading.Thread(target=self.automate_ffmpeg_setup, daemon=True).start()
        else:
            self.setup_label.config(text="✅ Engine Ready (System FFmpeg Found)", fg="#16a34a")
            self.setup_progress.set(100)
            self.setup_progress.pack_forget()

        # Metadata
        meta_frame = tk.Frame(root, bg="#f1f5f9", padx=20, pady=10)
        meta_frame.pack(fill="x")

        tk.Label(meta_frame, text="Book Title:", bg="#f1f5f9", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w")
        self.title_entry = tk.Entry(meta_frame, width=40)
        self.title_entry.grid(row=0, column=1, pady=5, padx=10)
        self.title_entry.insert(0, "My Audiobook")

        tk.Label(meta_frame, text="Author:", bg="#f1f5f9", font=("Arial", 10, "bold")).grid(row=1, column=0, sticky="w")
        self.author_entry = tk.Entry(meta_frame, width=40)
        self.author_entry.grid(row=1, column=1, pady=5, padx=10)
        self.author_entry.insert(0, "Unknown Author")

        # File List
        list_frame = tk.Frame(root, bg="white", bd=1, relief="sunken")
        list_frame.pack(fill="both", expand=True, padx=20, pady=10)

        self.tree = ttk.Treeview(list_frame, columns=("Name", "Size"), show="headings")
        self.tree.heading("Name", text="Filename")
        self.tree.heading("Size", text="Size")
        self.tree.column("Name", width=400)
        self.tree.column("Size", width=100)
        self.tree.pack(side="left", fill="both", expand=True)

        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side="right", fill="y")

        # Buttons
        btn_frame = tk.Frame(root, bg="#f1f5f9", pady=10)
        btn_frame.pack(fill="x", padx=20)

        tk.Button(btn_frame, text="+ Add Files", command=self.add_files, bg="#e2e8f0", padx=10).pack(side="left")
        tk.Button(btn_frame, text="Clear", command=self.clear_files, bg="#fee2e2", fg="#b91c1c", padx=10).pack(side="left", padx=10)
        tk.Button(btn_frame, text="Sort A-Z", command=self.sort_files, bg="#f0f9ff", padx=10).pack(side="left")

        # Build Button
        self.build_btn = tk.Button(root, text="BUILD M4B AUDIOBOOK", font=("Arial", 12, "bold"), 
                                   bg="#7c3aed", fg="white", pady=12, command=self.start_build)
        self.build_btn.pack(fill="x", padx=20, pady=20)

        # Status
        self.status_label = tk.Label(root, text="Ready", bg="#f1f5f9", font=("Arial", 9, "italic"))
        self.status_label.pack()

    def check_ffmpeg_silent(self):
        """Checks if FFmpeg is installed or exists in the local engine folder."""
        # Check local folder first
        local_bin = os.path.join(os.getcwd(), "ffmpeg_engine", "bin", "ffmpeg.exe" if os.name == 'nt' else "ffmpeg")
        if os.path.exists(local_bin):
            self.ffmpeg_path = local_bin
            return True

        try:
            startupinfo = None
            if os.name == 'nt':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            subprocess.run(['ffmpeg', '-version'], capture_output=True, startupinfo=startupinfo)
            self.ffmpeg_path = "ffmpeg"
            return True
        except FileNotFoundError:
            return False

    def automate_ffmpeg_setup(self):
        """Automatically downloads and extracts the correct FFmpeg version for the OS."""
        system = platform.system()
        engine_dir = os.path.join(os.getcwd(), "ffmpeg_engine")
        
        if not os.path.exists(engine_dir):
            os.makedirs(engine_dir)

        # Define specific direct download links
        if system == "Windows":
            url = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
            ext = ".zip"
        elif system == "Darwin": # Mac
            url = "https://evermeet.cx/ffmpeg/getrelease/zip"
            ext = ".zip"
        else: # Linux
            url = "https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz"
            ext = ".tar.xz"

        temp_file = os.path.join(engine_dir, f"ffmpeg_download{ext}")

        try:
            def progress_hook(count, block_size, total_size):
                percent = int(count * block_size * 100 / total_size)
                self.root.after(0, lambda: self.setup_progress.configure(value=percent))
                self.root.after(0, lambda: self.setup_label.config(text=f"Downloading Engine: {percent}%"))

            add_log = lambda m: self.root.after(0, lambda: self.setup_label.config(text=m))
            
            add_log("Starting Download (50MB+)...")
            urllib.request.urlretrieve(url, temp_file, reporthook=progress_hook)
            
            add_log("Extracting Engine... please wait.")
            if ext == ".zip":
                with zipfile.ZipFile(temp_file, 'r') as zip_ref:
                    zip_ref.extractall(engine_dir)
            else:
                with tarfile.open(temp_file, "r:xz") as tar_ref:
                    tar_ref.extractall(engine_dir)

            # Cleanup
            os.remove(temp_file)

            # Find the bin folder (FFmpeg zips often have a root folder)
            for root, dirs, files in os.walk(engine_dir):
                if "ffmpeg.exe" in files or "ffmpeg" in files:
                    binary_path = os.path.join(root, "ffmpeg.exe" if os.name == 'nt' else "ffmpeg")
                    # If it's unix, make it executable
                    if os.name != 'nt':
                        os.chmod(binary_path, 0o755)
                    self.ffmpeg_path = binary_path
                    break
            
            self.ffmpeg_ready = True
            self.root.after(0, lambda: self.setup_label.config(text="✅ Engine Downloaded & Configured!", fg="#16a34a"))
            self.root.after(0, lambda: self.setup_progress.pack_forget())
            
        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("Setup Error", f"Automatic setup failed: {e}\n\nYou may need to install it manually."))
            self.root.after(0, lambda: self.setup_label.config(text="❌ Setup Failed", fg="#991b1b"))

    def add_files(self):
        new_files = filedialog.askopenfilenames(filetypes=[("Audio Files", "*.mp3 *.m4a *.m4b")])
        if new_files:
            for f in new_files:
                size = os.path.getsize(f) / (1024 * 1024)
                self.files.append(f)
                self.tree.insert("", "end", values=(os.path.basename(f), f"{size:.2f} MB"))
            self.sort_files()

    def sort_files(self):
        self.files.sort(key=lambda x: os.path.basename(x).lower())
        self.refresh_tree()

    def clear_files(self):
        self.files = []
        self.refresh_tree()

    def refresh_tree(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
        for f in self.files:
            size = os.path.getsize(f) / (1024 * 1024)
            self.tree.insert("", "end", values=(os.path.basename(f), f"{size:.2f} MB"))

    def start_build(self):
        if not self.ffmpeg_ready:
            messagebox.showerror("Wait", "Please wait for the FFmpeg engine to finish downloading.")
            return

        if not self.files:
            messagebox.showwarning("Empty List", "Please add some audio files first.")
            return
        
        # Fixed typo: changed asksavesfilename to asksaveasfilename
        output_path = filedialog.asksaveasfilename(defaultextension=".m4b", 
                                                 initialfile=f"{self.title_entry.get()}.m4b",
                                                 filetypes=[("Audiobook", "*.m4b")])
        if not output_path:
            return

        self.build_btn.config(state="disabled", text="PROCESSING...")
        threading.Thread(target=self.run_ffmpeg, args=(output_path,), daemon=True).start()

    def run_ffmpeg(self, output_path):
        try:
            list_file = "ffmpeg_list.txt"
            with open(list_file, "w", encoding="utf-8") as f:
                for file_path in self.files:
                    safe_path = file_path.replace("'", "'\\''")
                    f.write(f"file '{safe_path}'\n")

            title = self.title_entry.get()
            author = self.author_entry.get()

            command = [
                self.ffmpeg_path, '-y', '-f', 'concat', '-safe', '0', '-i', list_file,
                '-metadata', f'title={title}',
                '-metadata', f'artist={author}',
                '-metadata', f'album={title}',
                '-c:a', 'aac', '-b:a', '128k',
                output_path
            ]

            self.update_status("Merging all parts into your Audiobook...")
            
            startupinfo = None
            if os.name == 'nt':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW

            result = subprocess.run(command, capture_output=True, text=True, startupinfo=startupinfo)

            if result.returncode == 0:
                self.root.after(0, lambda: messagebox.showinfo("Success", f"Audiobook created successfully!\n\nSaved to: {output_path}"))
            else:
                self.root.after(0, lambda: messagebox.showerror("Error", f"FFmpeg failed:\n{result.stderr}"))

            if os.path.exists(list_file):
                os.remove(list_file)

        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("System Error", str(e)))
        finally:
            self.root.after(0, self.reset_ui)

    def update_status(self, msg):
        self.root.after(0, lambda: self.status_label.config(text=msg))

    def reset_ui(self):
        self.build_btn.config(state="normal", text="BUILD M4B AUDIOBOOK")
        self.status_label.config(text="Ready")

if __name__ == "__main__":
    root = tk.Tk()
    app = AudiobookApp(root)
    root.mainloop()
